name: autoship

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      type:
        description: "patch|minor|major (blank = AI)"
        required: false
        default: ""

concurrency: ${{ github.workflow }}-${{ github.ref }}

permissions:
  contents: write
  pull-requests: write
  actions: read

jobs:
  autoship:
    runs-on: ubuntu-latest
    env:
      GH_TOKEN: ${{ secrets.AUTOSHIP_GH_TOKEN || secrets.GITHUB_TOKEN }}
      HAS_AUTOSHIP_PAT: ${{ secrets.AUTOSHIP_GH_TOKEN != '' }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Skip (no-op cases)
        id: gate
        run: |
          set -euo pipefail
          run=1

          msg="$(git log -1 --pretty=%B)"
          if echo "$msg" | grep -Eq '^chore: version packages|^chore: add (patch|minor|major) changeset for release|^chore: (patch|minor|major) release -'; then
            echo "skip: release commit"
            run=0
          fi

          cur="$(python3 -c 'import json;print(json.load(open("packages/cli/package.json"))["version"])' 2>/dev/null || true)"
          latest="$(git tag --list 'v*' --sort=-version:refname | head -n1 || true)"
          latest_ver="${latest#v}"
          if [ -n "${cur:-}" ] && [ -n "${latest_ver:-}" ] && [ "${cur}" != "${latest_ver}" ]; then
            echo "skip: pending publish (${latest} -> v${cur})"
            run=0
          fi

          files="$(git diff-tree --no-commit-id --name-only -r HEAD || true)"
          if echo "$files" | grep -Eq '^\.changeset/|^packages/cli/package\.json$|^CHANGELOG\.md$'; then
            echo "skip: release files touched"
            run=0
          fi

          if ls .changeset/*.md 2>/dev/null | grep -vE '/README\.md$' | grep -q .; then
            echo "skip: changesets exist"
            run=0
          fi

          if gh pr list --repo "$GITHUB_REPOSITORY" --state open --json title --jq '.[].title' | grep -q 'chore: .* release -'; then
            echo "skip: autoship release pr open"
            run=0
          fi

          if gh pr list --repo "$GITHUB_REPOSITORY" --state open --head "changeset-release/main" --json number --jq '.[0].number' | grep -q .; then
            echo "skip: version pr open"
            run=0
          fi

          if [ -n "${latest:-}" ] && [ "$(git rev-list --count "${latest}..HEAD")" = "0" ]; then
            echo "skip: no commits since ${latest}"
            run=0
          fi

          echo "run=${run}" >> "$GITHUB_OUTPUT"

      - uses: actions/setup-node@v4
        if: steps.gate.outputs.run == '1'
        with:
          node-version: 20

      - uses: oven-sh/setup-bun@v2
        if: steps.gate.outputs.run == '1' && env.HAS_AUTOSHIP_PAT != 'true'

      - uses: dtolnay/rust-toolchain@stable
        if: steps.gate.outputs.run == '1' && env.HAS_AUTOSHIP_PAT != 'true'

      - uses: Swatinem/rust-cache@v2
        if: steps.gate.outputs.run == '1' && env.HAS_AUTOSHIP_PAT != 'true'

      - name: Install autoship
        if: steps.gate.outputs.run == '1'
        run: npm i -g autoship@0.1.0

      - name: git identity
        if: steps.gate.outputs.run == '1'
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Run autoship (monorepo)
        if: steps.gate.outputs.run == '1'
        env:
          AI_GATEWAY_API_KEY: ${{ secrets.AI_GATEWAY_API_KEY || vars.AI_GATEWAY_API_KEY }}
          INPUT_TYPE: ${{ inputs.type }}
        run: |
          node --input-type=module <<'NODE'
          import { execSync } from 'node:child_process';
          import fs from 'node:fs';
          import path from 'node:path';

          const npmRoot = execSync('npm root -g', { encoding: 'utf8' }).trim();
          const gitMod = await import(`file://${path.join(npmRoot, 'autoship/dist/git.js')}`);
          const ghMod = await import(`file://${path.join(npmRoot, 'autoship/dist/github.js')}`);
          const aiMod = await import(`file://${path.join(npmRoot, 'autoship/dist/ai.js')}`);

          const { GitOperations } = gitMod;
          const { GitHubOperations } = ghMod;
          const { generateChangesetMessage, suggestReleaseType } = aiMod;

          const cfg = {
            owner: 'Dhruv2mars',
            repo: 'mdv',
            baseBranch: 'main',
            cloneUrl: 'https://github.com/Dhruv2mars/mdv.git',
          };

          const git = new GitOperations(cfg);
          const github = new GitHubOperations(cfg);

          await git.clone();

          const workDir = git.getWorkDir();
          // Allow pushing branches from the temp clone.
          const authRemote = `https://x-access-token:${process.env.GH_TOKEN}@github.com/Dhruv2mars/mdv.git`;
          execSync(`git remote set-url origin "${authRemote}"`, { cwd: workDir });
          const cliPkgPath = path.join(workDir, 'packages/cli/package.json');
          const cliPkg = JSON.parse(fs.readFileSync(cliPkgPath, 'utf8'));
          const packageName = cliPkg.name;

          const latestTag = await git.getLatestVersionTag();
          let ctx = {
            commits: [],
            diff: '',
            filesChanged: [],
            insertions: 0,
            deletions: 0,
            previousVersion: latestTag ?? 'unknown',
          };

          if (latestTag) {
            const [commits, diffSummary, diff] = await Promise.all([
              git.getCommitsSinceTag(latestTag),
              git.getDiffSummary(latestTag),
              git.getFullDiffSinceTag(latestTag),
            ]);
            ctx = {
              commits,
              diff,
              filesChanged: diffSummary.files,
              insertions: diffSummary.insertions,
              deletions: diffSummary.deletions,
              previousVersion: latestTag,
            };
          } else {
            ctx.commits = await git.getRecentCommits(15);
          }

          let type = String(process.env.INPUT_TYPE || '').trim();
          if (!type) type = await suggestReleaseType(ctx);
          if (!['patch', 'minor', 'major'].includes(type)) type = 'patch';

          let message = '';
          try {
            message = await generateChangesetMessage(packageName, type, ctx);
          } catch {
            message = `Release ${type}`;
          }
          message = String(message).replace(/\s+/g, ' ').trim();
          if (!message) message = `Release ${type}`;

          const fullOptions = { type, message, skipConfirmations: true };
          const branchName = `release/${type}-${Date.now()}`;

          await git.createBranch(branchName);
          await git.generateChangeset(fullOptions, packageName);
          await git.stageAndCommit(`chore: add ${type} changeset for release`);
          await git.push(branchName);

          const prTitle = `chore: ${type} release - ${message.slice(0, 50)}`;
          const prBody = `## Release Changeset\n\n**Type:** ${type}\n\n**Changes:**\n${message}\n\n---\n*This PR was created automatically by autoship*`;
          const pr = await github.createPullRequest(branchName, prTitle, prBody);

          // PR workflows don't run when PR is created by GITHUB_TOKEN.
          // If no PAT configured, run checks locally in the temp clone.
          const hasPat = String(process.env.HAS_AUTOSHIP_PAT || '') === 'true';
          if (hasPat) {
            const prChecks = await github.waitForChecks(pr.number);
            if (!prChecks.success) throw new Error('changeset PR checks failed');
          } else {
            execSync('bun install --frozen-lockfile', {
              cwd: workDir,
              stdio: 'inherit',
              env: { ...process.env, MDV_SKIP_DOWNLOAD: '1' },
            });
            execSync('bun run lint', { cwd: workDir, stdio: 'inherit' });
            execSync('bun run test', { cwd: workDir, stdio: 'inherit' });
          }
          await github.mergePullRequest(pr.number, 'squash');

          const versionPr = await github.waitForVersionPackagesPR();
          if (hasPat) {
            const vChecks = await github.waitForChecks(versionPr.number);
            if (!vChecks.success) throw new Error('version PR checks failed');
          }
          await github.mergePullRequest(versionPr.number, 'squash');

          await git.cleanup();
          NODE
