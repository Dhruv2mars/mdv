name: autoship

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      type:
        description: "patch|minor|major (blank = AI)"
        required: false
        default: ""

concurrency: ${{ github.workflow }}-${{ github.ref }}

permissions:
  contents: write
  pull-requests: write
  actions: read

jobs:
  autoship:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Skip (no-op cases)
        id: gate
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          run=1

          msg="$(git log -1 --pretty=%B)"
          if echo "$msg" | grep -Eq '^chore: version packages|^chore: add (patch|minor|major) changeset for release|^chore: (patch|minor|major) release -'; then
            echo "skip: release commit"
            run=0
          fi

          if ls .changeset/*.md 2>/dev/null | grep -vE '/README\.md$' | grep -q .; then
            echo "skip: changesets exist"
            run=0
          fi

          if gh pr list --repo "$GITHUB_REPOSITORY" --state open --json title --jq '.[].title' | grep -q 'chore: .* release -'; then
            echo "skip: autoship release pr open"
            run=0
          fi

          if gh pr list --repo "$GITHUB_REPOSITORY" --state open --head "changeset-release/main" --json number --jq '.[0].number' | grep -q .; then
            echo "skip: version pr open"
            run=0
          fi

          latest="$(git tag --list 'v*' --sort=-version:refname | head -n1 || true)"
          if [ -n "${latest:-}" ] && [ "$(git rev-list --count "${latest}..HEAD")" = "0" ]; then
            echo "skip: no commits since ${latest}"
            run=0
          fi

          echo "run=${run}" >> "$GITHUB_OUTPUT"

      - uses: actions/setup-node@v4
        if: steps.gate.outputs.run == '1'
        with:
          node-version: 20

      - name: Install autoship
        if: steps.gate.outputs.run == '1'
        run: npm i -g autoship@0.1.0

      - name: git identity
        if: steps.gate.outputs.run == '1'
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Run autoship (monorepo)
        if: steps.gate.outputs.run == '1'
        env:
          AI_GATEWAY_API_KEY: ${{ secrets.AI_GATEWAY_API_KEY }}
          INPUT_TYPE: ${{ inputs.type }}
          GH_TOKEN: ${{ github.token }}
        run: |
          node --input-type=module <<'NODE'
          import { execSync } from 'node:child_process';
          import fs from 'node:fs';
          import path from 'node:path';

          const npmRoot = execSync('npm root -g', { encoding: 'utf8' }).trim();
          const gitMod = await import(`file://${path.join(npmRoot, 'autoship/dist/git.js')}`);
          const ghMod = await import(`file://${path.join(npmRoot, 'autoship/dist/github.js')}`);
          const aiMod = await import(`file://${path.join(npmRoot, 'autoship/dist/ai.js')}`);

          const { GitOperations } = gitMod;
          const { GitHubOperations } = ghMod;
          const { generateChangesetMessage, suggestReleaseType } = aiMod;

          const cfg = {
            owner: 'Dhruv2mars',
            repo: 'mdv',
            baseBranch: 'main',
            cloneUrl: 'https://github.com/Dhruv2mars/mdv.git',
          };

          const git = new GitOperations(cfg);
          const github = new GitHubOperations(cfg);

          await git.clone();

          const workDir = git.getWorkDir();
          const cliPkgPath = path.join(workDir, 'packages/cli/package.json');
          const cliPkg = JSON.parse(fs.readFileSync(cliPkgPath, 'utf8'));
          const packageName = cliPkg.name;

          const latestTag = await git.getLatestVersionTag();
          let ctx = {
            commits: [],
            diff: '',
            filesChanged: [],
            insertions: 0,
            deletions: 0,
            previousVersion: latestTag ?? 'unknown',
          };

          if (latestTag) {
            const [commits, diffSummary, diff] = await Promise.all([
              git.getCommitsSinceTag(latestTag),
              git.getDiffSummary(latestTag),
              git.getFullDiffSinceTag(latestTag),
            ]);
            ctx = {
              commits,
              diff,
              filesChanged: diffSummary.files,
              insertions: diffSummary.insertions,
              deletions: diffSummary.deletions,
              previousVersion: latestTag,
            };
          } else {
            ctx.commits = await git.getRecentCommits(15);
          }

          let type = String(process.env.INPUT_TYPE || '').trim();
          if (!type) type = await suggestReleaseType(ctx);
          if (!['patch', 'minor', 'major'].includes(type)) type = 'patch';

          let message = '';
          try {
            message = await generateChangesetMessage(packageName, type, ctx);
          } catch {
            message = `Release ${type}`;
          }
          message = String(message).replace(/\s+/g, ' ').trim();
          if (!message) message = `Release ${type}`;

          const fullOptions = { type, message, skipConfirmations: true };
          const branchName = `release/${type}-${Date.now()}`;

          await git.createBranch(branchName);
          await git.generateChangeset(fullOptions, packageName);
          await git.stageAndCommit(`chore: add ${type} changeset for release`);
          await git.push(branchName);

          const prTitle = `chore: ${type} release - ${message.slice(0, 50)}`;
          const prBody = `## Release Changeset\n\n**Type:** ${type}\n\n**Changes:**\n${message}\n\n---\n*This PR was created automatically by autoship*`;
          const pr = await github.createPullRequest(branchName, prTitle, prBody);

          const prChecks = await github.waitForChecks(pr.number);
          if (!prChecks.success) throw new Error('changeset PR checks failed');
          await github.mergePullRequest(pr.number, 'squash');

          const versionPr = await github.waitForVersionPackagesPR();
          const vChecks = await github.waitForChecks(versionPr.number);
          if (!vChecks.success) throw new Error('version PR checks failed');
          await github.mergePullRequest(versionPr.number, 'squash');

          await git.cleanup();
          NODE
